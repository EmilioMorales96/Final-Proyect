import express from 'express';
import db from '../models/index.js';
const { Template, Tag, User, Like, Comment } = db;
import { userHasAccess } from '../utils/access.js';
import authenticateToken from '../middleware/auth.middleware.js';

const router = express.Router();

// Create template (authenticated only)
router.post('/', authenticateToken, async (req, res) => {
  try {
    console.log('Creating template with data:', req.body);
    const { title, description, topic, imageUrl, tags, isPublic, accessUsers, questions } = req.body;

    // Basic validation
    if (!title || !title.trim()) {
      return res.status(400).json({ message: 'Title is required.' });
    }
    
    if (!description || !description.trim()) {
      return res.status(400).json({ message: 'Description is required.' });
    }

    if (!topic) {
      return res.status(400).json({ message: 'Topic is required.' });
    }

    // Questions validation
    if (!Array.isArray(questions) || questions.length === 0) {
      return res.status(400).json({ message: 'You must add at least one question.' });
    }
    if (questions.some(q => !q.title || !q.title.trim() || !q.questionText || !q.questionText.trim())) {
      return res.status(400).json({ message: "Each question must have a title and question text." });
    }

    // Check question type limits
    const typeCounts = {};
    questions.forEach(q => {
      typeCounts[q.type] = (typeCounts[q.type] || 0) + 1;
    });

    const limitedTypes = ['text', 'textarea', 'integer', 'checkbox'];
    const maxPerType = 4;
    
    for (const type of limitedTypes) {
      if (typeCounts[type] > maxPerType) {
        return res.status(400).json({ 
          message: `Maximum ${maxPerType} questions allowed for type: ${type}` 
        });
      }
    }

    console.log('Creating template object...');
    const template = await Template.create({
      title: title.trim(),
      description: description.trim(),
      topic,
      imageUrl: imageUrl || null,
      isPublic: isPublic !== undefined ? isPublic : true,
      accessUsers: Array.isArray(accessUsers) ? JSON.stringify(accessUsers) : null,
      authorId: req.user.id,
      questions,
    });

    console.log('Template created successfully:', template.id);

    // Associate tags (create if not exist)
    if (Array.isArray(tags)) {
      const tagInstances = await Promise.all(
        tags.map(name =>
          Tag.findOrCreate({ where: { name: name.trim().toLowerCase() } }).then(([tag]) => tag)
        )
      );
      await template.setTags(tagInstances);
    }

    res.status(201).json(template);
  } catch (err) {
    console.error("Error creating template:", err);
    console.error("Error details:", err.message);
    if (err.name === 'SequelizeValidationError') {
      const validationErrors = err.errors.map(error => ({
        field: error.path,
        message: error.message
      }));
      return res.status(400).json({ 
        message: 'Validation error', 
        errors: validationErrors 
      });
    }
    res.status(500).json({ message: 'Error creating template.', error: err.message });
  }
});

// Get all accessible templates
router.get('/', authenticateToken, async (req, res) => {
  console.log("User in /api/templates:", req.user);
  try {
    const templates = await db.Template.findAll({
      include: [
        {
          model: db.User,
          as: "FavoredBy",
          attributes: ["id"],
          through: { attributes: [] }
        },
        {
          model: db.Tag,
          as: "Tags", 
          through: { attributes: [] }
        },
        {
          model: db.User,
          as: "author", 
          attributes: ["id", "username", "avatar"]
        }
      ],
      order: [["updatedAt", "DESC"]]
    });

    // Filter templates based on user access
    // Show all public templates + private templates the user has access to
    const accessibleTemplates = templates.filter(template => {
      return template.isPublic || userHasAccess(template, req.user.id, req.user.role);
    });

    res.json(accessibleTemplates);
  } catch (err) {
    console.error("Error fetching templates:", err);
    res.status(500).json({ message: 'Error fetching templates', error: err.message });
  }
// Get recent templates for home page
router.get('/recent', async (req, res) => {
  try {
    const templates = await Template.findAll({
      where: { isPublic: true },
      include: [
        {
          model: User,
          as: 'author',
          attributes: ['id', 'username']
        },
        {
          model: Tag,
          through: { attributes: [] },
          attributes: ['name']
        }
      ],
      order: [['createdAt', 'DESC']],
      limit: 8
    });
    
    res.json(templates);
  } catch (error) {
    console.error('Error fetching recent templates:', error);
    res.status(500).json({ message: 'Error fetching recent templates' });
  }
});

// Get popular templates for home page
router.get('/popular', async (req, res) => {
  try {
    const templates = await Template.findAll({
      where: { isPublic: true },
      include: [
        {
          model: User,
          as: 'author',
          attributes: ['id', 'username']
        },
        {
          model: Like,
          attributes: []
        },
        {
          model: Comment,
          attributes: []
        }
      ],
      attributes: [
        'id', 'title', 'description', 'topic', 'createdAt',
        [db.sequelize.fn('COUNT', db.sequelize.col('likes.id')), 'likesCount'],
        [db.sequelize.fn('COUNT', db.sequelize.col('Comments.id')), 'commentsCount']
      ],
      group: ['Template.id', 'author.id'],
      order: [
        [db.sequelize.literal('("likesCount" + "commentsCount")'), 'DESC'],
        ['createdAt', 'DESC']
      ],
      limit: 5
    });
    
    res.json(templates);
  } catch (error) {
    console.error('Error fetching popular templates:', error);
    res.status(500).json({ message: 'Error fetching popular templates' });
  }
});

// Get a template by ID (with access control)
router.get('/:id', authenticateToken, async (req, res) => {
  try {
    console.log(`[TEMPLATE] GET /:id - User ${req.user.id} requesting template ${req.params.id}`);
    const template = await Template.findByPk(req.params.id, {
      include: [
        {
          model: Tag,
          as: "Tags",
          through: { attributes: [] }
        },
        {
          model: db.User,
          as: "FavoredBy",
          attributes: ["id"],
          through: { attributes: [] }
        },
        {
          model: db.User,
          as: "author",
          attributes: ["id", "username", "avatar"]
        }
      ]
    });
    
    if (!template) {
      console.log(`[TEMPLATE] Template ${req.params.id} not found`);
      return res.status(404).json({ message: 'Template not found' });
    }

    console.log(`[TEMPLATE] Template found: ${template.title}, isPublic: ${template.isPublic}, authorId: ${template.authorId}`);
    
    if (template.isPublic || userHasAccess(template, req.user.id, req.user.role)) {
      console.log(`[TEMPLATE] Access granted to template ${req.params.id}`);
      return res.json(template);
    }
    
    console.log(`[TEMPLATE] Access denied to template ${req.params.id}`);
    return res.status(403).json({ message: 'You do not have access to this template.' });
  } catch (err) {
    console.error(`[TEMPLATE] Error fetching template ${req.params.id}:`, err);
    res.status(500).json({ message: 'Error fetching template.', error: err.message });
  }
});

// Update template (owner only)
router.put('/:id', authenticateToken, async (req, res) => {
  try {
    const template = await Template.findByPk(req.params.id);
    if (!template) return res.status(404).json({ message: 'Template not found' });

    const hasAccess = userHasAccess(template, req.user.id, req.user.role);
    if (!hasAccess) {
      return res.status(403).json({ message: 'You do not have permission to edit this template.' });
    }

    const { tags, ...updateData } = req.body;
    await template.update(updateData);

    // Update tags association
    if (Array.isArray(tags)) {
      const tagInstances = await Promise.all(
        tags.map(name =>
          Tag.findOrCreate({ where: { name: name.trim().toLowerCase() } }).then(([tag]) => tag)
        )
      );
      await template.setTags(tagInstances);
    }

    res.json(template);
  } catch (err) {
    res.status(500).json({ message: 'Error updating template', error: err.message });
  }
});

// Delete template (owner only)
router.delete('/:id', authenticateToken, async (req, res) => {
  try {
    const template = await Template.findByPk(req.params.id);
    if (!template) return res.status(404).json({ message: 'Template not found' });

    if (template.authorId !== req.user.id) {
      return res.status(403).json({ message: 'You do not have permission to delete this template.' });
    }

    await template.destroy();
    res.json({ message: 'Template deleted' });
  } catch (err) {
    res.status(500).json({ message: 'Error deleting template', error: err.message });
  }
});

// Get template analytics (owner/admin only)
router.get('/:id/analytics', authenticateToken, async (req, res) => {
  try {
    const templateId = req.params.id;
    const template = await Template.findByPk(templateId);
    
    if (!template) {
      return res.status(404).json({ message: 'Template not found' });
    }

    // Check if user has access to view analytics
    if (template.authorId !== req.user.id && req.user.role !== 'admin') {
      return res.status(403).json({ message: 'Access denied' });
    }

    // Get all forms for this template
    const forms = await db.Form.findAll({
      where: { templateId },
      include: [{ model: db.User, attributes: ['id'] }]
    });

    const analytics = {
      totalResponses: forms.length,
      uniqueUsers: new Set(forms.map(f => f.userId)).size,
      completionRate: 100, // Could calculate based on partial submissions
      averageCompletionTime: Math.round(Math.random() * 120 + 30), // Mock data
      questionAnalytics: [],
      timeline: []
    };

    // Analyze question responses
    if (template.questions && Array.isArray(template.questions)) {
      template.questions.forEach((question, index) => {
        const questionResponses = forms
          .map(form => form.answers && form.answers[`question_${index}`])
          .filter(answer => answer !== undefined && answer !== null && answer !== '');

        const questionAnalysis = {
          questionText: question.questionText || question.title,
          type: question.type,
          totalResponses: questionResponses.length
        };

        if (['radio', 'checkbox', 'dropdown'].includes(question.type)) {
          // Analyze categorical data
          const distribution = {};
          questionResponses.forEach(answer => {
            if (Array.isArray(answer)) {
              answer.forEach(item => {
                distribution[item] = (distribution[item] || 0) + 1;
              });
            } else {
              distribution[answer] = (distribution[answer] || 0) + 1;
            }
          });
          
          questionAnalysis.distribution = Object.entries(distribution)
            .map(([value, count]) => ({ value, count }))
            .sort((a, b) => b.count - a.count);
            
        } else if (['rating', 'linear'].includes(question.type)) {
          // Analyze numeric data
          const numericResponses = questionResponses
            .map(answer => parseInt(answer))
            .filter(num => !isNaN(num));
            
          const distribution = {};
          numericResponses.forEach(num => {
            distribution[num] = (distribution[num] || 0) + 1;
          });
          
          questionAnalysis.distribution = Object.entries(distribution)
            .map(([value, count]) => ({ value: parseInt(value), count }))
            .sort((a, b) => a.value - b.value);
            
          questionAnalysis.average = numericResponses.length > 0 
            ? (numericResponses.reduce((sum, num) => sum + num, 0) / numericResponses.length).toFixed(2)
            : 0;
            
        } else {
          // Analyze text data
          const lengths = questionResponses.map(answer => String(answer).length);
          questionAnalysis.averageLength = lengths.length > 0 
            ? Math.round(lengths.reduce((sum, len) => sum + len, 0) / lengths.length)
            : 0;
            
          // Find most common answer (simplified)
          const answerCounts = {};
          questionResponses.forEach(answer => {
            const normalized = String(answer).toLowerCase().trim();
            answerCounts[normalized] = (answerCounts[normalized] || 0) + 1;
          });
          
          const mostCommonEntry = Object.entries(answerCounts)
            .sort(([,a], [,b]) => b - a)[0];
          questionAnalysis.mostCommon = mostCommonEntry ? mostCommonEntry[0] : 'N/A';
        }

        analytics.questionAnalytics.push(questionAnalysis);
      });
    }

    // Generate timeline data (last 30 days)
    const timeline = [];
    const now = new Date();
    for (let i = 29; i >= 0; i--) {
      const date = new Date(now);
      date.setDate(date.getDate() - i);
      const dateStr = date.toISOString().split('T')[0];
      
      const dayResponses = forms.filter(form => {
        const formDate = new Date(form.createdAt).toISOString().split('T')[0];
        return formDate === dateStr;
      }).length;
      
      timeline.push({
        date: dateStr,
        responses: dayResponses
      });
    }
    analytics.timeline = timeline;

    res.json(analytics);
  } catch (error) {
    console.error('Error generating analytics:', error);
    res.status(500).json({ message: 'Error generating analytics' });
  }
});

export default router;
